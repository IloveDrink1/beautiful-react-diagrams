import { getElementRect } from '../../shared/funcs/elementsUtils';
import { transformCoordinates } from '../../shared/funcs/pointTransformations';

/**
 * A frozen object to identify the entities type.
 * An entity is a library generated element (such as a Node or a Port).
 * An entity can only be of type "port" or "node"
 */
export const EntityTypes = Object.freeze({
  port: Symbol('brd-entity-type-port'),
  node: Symbol('brd-entity-type-node'),
  unknown: Symbol('brd-entity-type-unknown'),
});

export const AlignmentTypes = Object.freeze({
  top: Symbol('brd-entity-alignment-top'),
  left: Symbol('brd-entity-alignment-left'),
  right: Symbol('brd-entity-alignment-right'),
  bottom: Symbol('brd-entity-alignment-bottom'),
  unknown: Symbol('brd-entity-alignment-unknown'),
});

/**
 * Returns the actual DOM element having the given `id` by querying the data-brd-id attribute
 */
export const getEntityElement = (id) => document.querySelector(`[data-brd-id='${id}']`);

/**
 * Takes an DOM element and returns its entity type.
 * If the given element has been generated by the library it can only be of the types defined by EntityTypes.
 */
export const getEntityType = (el) => {
  if (el.hasAttribute('data-brd-type')) {
    const attribute = el.getAttribute('data-brd-type');
    return EntityTypes[attribute] || EntityTypes.port;
  }

  return EntityTypes.unknown;
};

/**
 * Takes and entity element (a port or a node element) and returns its relative coordinates.
 */
export const getEntityCoordinates = (entityElement, canvasEl, scale) => {
  if (entityElement && canvasEl) {
    const parentRect = getElementRect(canvasEl);
    const rect = getElementRect(entityElement);
    const coords = [
      (rect.left + (rect.width / 2)) - parentRect.left,
      (rect.top + (rect.height / 2)) - parentRect.top,
    ];

    return transformCoordinates(coords, scale);
  }

  return null;
};

/**
 * checks if a node's ports array is existing and is valid
 */
const validPortArray = (portArray) => portArray && Array.isArray(portArray) && portArray.length > 0;

/**
 * // TODO: document
 */
const searchNodeByPortType = (portType) => (portId, nodes) => {
  for (let nodeIndex = 0; nodeIndex < nodes.length; nodeIndex += 1) {
    const node = nodes[nodeIndex];

    if (validPortArray(node[portType])) {
      for (let portIndex = 0; portIndex < node[portType].length; portIndex += 1) {
        const port = node[portType][portIndex];

        if (port.id === portId) {
          return node;
        }
      }
    }
  }

  return null;
};

const searchNodeByInputs = searchNodeByPortType('inputs');
const searchNodeByOutputs = searchNodeByPortType('outputs');

export const getPortAlignment = (port, nodes = []) => {
  let node = searchNodeByInputs(port, nodes);

  if (node) {
    return AlignmentTypes[node.inputsAlignment] || AlignmentTypes.unknown;
  }

  node = searchNodeByOutputs(port, nodes);

  return node ? AlignmentTypes[node.outputsAlignment] : AlignmentTypes.unknown;
};
